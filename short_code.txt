106fn2IIPQghMdOcpcm7

octotree расширение для хром

- Основы GIT -

git log        - просмотр истории коммитов и изменений
git log -1     - посмотреть только последний коммит
git log -1 -p  - показать что было именно сделано в коммите
git reflog	мы можем вернуться и к удаленному коммиту посмотреть его(пишет изменения не только коммитов, но и всех операций которые были совершенны во время работы в репозитории)
git show <хеш файла>	показывает полную информацию по файлу, что делали что меняли

- Статусы файлов Git -

modified    - файл изменен, но еще не попал в коммит
committed   - после того как файл зафиксирован в истории изменений
staged      - файл подготовленный к коммиту (в области staged area или index)
tracked     - файл под версионным контролем GIT 
untracked   - файл без версионного контроля GIT 

git add <file> 
- добавление файла к будущему коммиту если у нас есть несколько файлов которые надо разделить по разным коммитам, то надо выполнить эту команду с указанием конкретных имен:

	git add <file1> <file2> 
после чего добалвяем эти два файла в первый коммит:
	git commit -m 'commit massage' - запись коммита без открытия редактора.

git checkout --<file> - отменить изменения в файле которые не отслеживается гитом но изменен с последнего коммита.

git diff -- staged    - показывает конкретные изменения по строчкам которые изменены по состоянию последнего коммита

- текущий статус репозитория
git status

cretaceous
douchebag


- запись коммита + добавление файла сразу включает в себя команды
\\ git add <file> git commit
git commit -a

- просмотр истории коммитов (пишет изменения об истории коммитов)
git log 
git log --oneline

- но мы можем вернуться и к удаленному коммиту посмотреть его(пишет изменения не
только коммитов но и всех операций которые были совершенны 
во время работы в репозитории)


   //                           \\
-- \\ Работа с историей коммита // --

- вернуться к нужному коммиту, скопировав нужный хеш 
git reset хеш коммита

- сброс текущего состояния истории
git reset 8f56aaa <- ХЕШ созданного комита

- отменить последствия в коммите (не сбрасывает состояние репозитория на конкретный коммит, а создает новый коммит который отменяет действия совершенные в предыдущем)
git revert хеш каммита

- сброс состояния файла на состояние последнего коммита
git restore 

   //                   \\
-- \\ Ветки репозитория // --

- master самая главная ветка работы всей программы
- другие ветки создаются для паралельной работы над файлами, создается временная копия на текущий момент состояния репозитория, работаем, записываем изменения. И эта ветка будет содержать набор новых коммитов которые надо будет потом перенести в master  ветку. Таким образом разарботчики могли паралельно делать новые изменения в програмном обеспечении не пересекаясь друг с другом. 

\\ просмотреть доступные ветки в репозитории
- git branch (* в названии ветки показывает текущую ветку где мы находимся)

\\ создать новую ветку
- git branch <name>

\\ переключится на другую ветку
- git checkout <name>

\\ создание копии ветки 1 находясь на ветке 2, (<copyBranch> имя ветки от куда надо скопировать состояние для создания новой ветки <newBrenchName>)
- git branch <newBrenchName> <copyBranch>

\\ создание новой ветки и автоматическое переключение на нее
- git checkout -b dev-test (dev-test - новое имя ветки, -b создаст ее если при переключении такой не будет, и автоматически на нее сразу переключится после создания)

   //                       \\
-- \\ удаленные репозитории // --

// настройка SSH подключения, файл создается по пути в папке потзователя с расширением *.pub -> c/Users/User/.ssh/id_rsa.pub
- ssh-keygen
- после система запросит ввести passphrase, для защиты, и потом повторить ее
- для просмотра содержимого SSH файла надо открыть для просмотра файл id_rsa.pub

// для загрузки изменений на локальном компьютере в ГИТХАБ 
- git push

// загрузка данных из удаленного репозитория ГИТ ХАБ
- git pull

// обновить текущую синхрониззацию по данным удаленного репозитория.
- git fetch 

<<<<<<< HEAD
//если при загрузке вышла ошибка на отсутствие нужной ветки, это значи что на удаленном репозитории нет такой ветки, надо создать ее на удаленном репозитории сначала, а потом опять выполнить гит пуш, либо использовать такую команду. 
- git push -u origin <vetka> (это командой мы хотим загрузить с текущей локальной ветке на удаленную (origin) ветку с таким же именем.

=======
// если при загрузке вышла ошибка на отсутствие нужной ветки, это значи что на удаленном репозитории нет такой ветки, надо создать ее на удаленном репозитории сначала, а потом опять выполнить гит пуш, либо использовать такую команду. 
- git push -u origin <vetka> (это командой мы хотим загрузить с текущей локальной ветке на удаленную (origin) ветку с таким же именем.

// удаление ненужной ветки
- git branch -d <vetka1> <vetka2> (через пробел можно писать несколько веток для удаления)
- git --delete origi <vetka1> <vetka2> (для удаления веток в удаленном репозитории, так как если мы удалим локально, то удаленно они все равно остануться)

// Объеденяет изменения различных веток в 1
- git merge

   //                       \\
-- \\     Перенос ветки     // --

// Rebase - процесс переноса изменения ветки, а именно процесс смены СТАРТА ветки. Процесс когда работа другого разработчика может влиять на мою часть, и потому требуется учитывать и его изменения. Вместо merge можно как раз использовать Rebase, который мои изменения перемещает в тот или инной момент времени. 
- git rebase <vetka>

   //                      \\
-- \\ Управление версиями  // --

// версией продкта в ГИт называет teg и оозначает версию готовой программы, версией записывается последний коммит, формат записи - 1.0.0
- git tag <1.0.0>

// команда работает так же для просмотра версий которые есть 
- git tag

// а так же удаления ненужного тега 
- git tag -d <tag_name>

// для загрузки тегов в ГИТХАБ используем команду 
- git push --tags

// для того чтобы удалить ненужный тег из удаленного репозитория используется команда <tag_name> - тот тег который надо удалить.
- git push --delete origin <tag_name>
>>>>>>> main

   //                              \\
-- \\ Stash - временное хранилище  // --

// для временного хранения изменений которые мы не хотим включать в общий коммит, мы можем воспользоватся командой git stash               - которая создает временное хранилище изменений файла

- git stash             - создать новое временное хранилище (находясь на нужной нам ветке, и имея в изменениях требуемые файлы)
- git stash push <file> - добавить файл к уже существующему stash на текущей ветке. 
- git stash pop         - применить изменения из другой ветки
- git stash list        - посмотреть список активных stash хранилищ

   //                              \\
-- \\ Squash - склеивание коммитов // --

// операция необходима чтобы работа над кодом была в лучшем виде чем куча разных коммитов. Если при разработке функционала мы сделали что то, потом сделали коммит, потом исправили, потом опять коммит, и так далее, и таких коммитов может быть много, и для того чтобы все это объеденить в 1 надо использовать эту команду.

- git merge <branch> --squash - перенос изменений через squash
- git rebase -i HEAD~X - склеить Х коммитов между собой.

   //                                          \\
-- \\ Cherry Pick - перенос отдельных коммитов // --

// перенос себе на ветку только нужного количества коммитов, вместо того чтобы заливать себе все что касается всего кода.

- git cherry-pick <IDcommit> - перенести коммит на текущую ветку
- git cherry-pick <branch> - перенести последний коммит указанной ветки
- git cherry-pick ..<branch> - перенести все коммиты с ветки

   //                             \\
-- \\ ammend - перезапись коммита // --

// если мы сделали коммит и поняли что в нем что то не так, можно исправить это

- git commit --ammend (последний коммит должен быть перезаписан, но даже изменненный комиит не убирает из истории ГИТА у файла обновляется хешь и можно восстановить его старой версии)

   //                    \\
-- \\ решение конфликтов // --

// помогает в ситуации когда два разработчика на разных ветках вместе изменяли один и тот же файл 

- редактирование необходимо производить вручную.

   //      \\
-- \\ Fork // --

// это копия существующего репозитория/продукта другого разработчика


--------------------------------
Для добавления в конец файла используй ">>". Одна ">" перезаписывает файл. echo "что игнорировать" >> .gitignore
Основной синтаксис файла .gitignore:
1 Каждая строка - отдельный шаблон
2 Пустые строки игнорируются
3 Строки начинающиеся с # являются комментариями
4 Символ слеша "/" в начале строки указывает на текущую папку (где лежит .gitignore)
5 Звёздочка() заменяет любое количество символов
6 Две звёздочки(*) используются для указания всех подпапок.
7 Восклицательный знак(!) в начале строки инвертирует шаблон (используется для исключений)
8 Для экранирования спецсимволов используется обратный слэш "\". Для игнорирования всей директории, правило должно оканчиваться на слэш(/), в противном случае правило считается именем файла.
-------------------------------

// .gitkeep и .gitignor файлы для исключений 

- .gitkeep -> Сохраняет пустые директории в общем репозитории. Требуется для того чтобы показать какую то папку в которой нет файлов, но гит не заносит их в индекс пока она пустая. 

-gitignore -> Игнорирует некоторые файлы от попадания в общий индекс репозитория.


