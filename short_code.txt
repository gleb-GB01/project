106fn2IIPQghMdOcpcm7

- текущий статус репозитория
git status

- добавление файла к будущему коммиту
git add <file>

- записать коммит
git commit
// git commit -m 'commit massage' - запись коммита без открытия
редактора.

- запись коммита + добавление файла сразу включает в себя команды
\\ git add <file> git commit
git commit -a

- просмотр истории коммитов (пишет изменения об истории коммитов)
git log 
git log --oneline

- но мы можем вернуться и к удаленному коммиту посмотреть его(пишет изменения не
только коммитов но и всех операций которые были совершенны 
во время работы в репозитории)
git reflog

   //                           \\
-- \\ Работа с историей коммита // --

- вернуться к нужному коммиту, скопировав нужный хеш 
git reset хеш коммита

- сброс текущего состояния истории
git reset 8f56aaa <- ХЕШ созданного комита

- отменить последствия в коммите (не сбрасывает состояние репозитория на конкретный коммит, а создает новый коммит который отменяет действия совершенные в предыдущем)
git revert хеш каммита

- сброс состояния файла на состояние последнего коммита
git restore 

   //                   \\
-- \\ Ветки репозитория // --

- master самая главная ветка работы всей программы
- другие ветки создаются для паралельной работы над файлами, создается временная копия на текущий момент состояния репозитория, работаем, записываем изменения. И эта ветка будет содержать набор новых коммитов которые надо будет потом перенести в master  ветку. Таким образом разарботчики могли паралельно делать новые изменения в програмном обеспечении не пересекаясь друг с другом. 

\\ просмотреть доступные ветки в репозитории
- git branch (* в названии ветки показывает текущую ветку где мы находимся)

\\ создать новую ветку
- git branch <name>

\\ переключится на другую ветку
- git checkout <name>

\\ создание копии ветки 1 находясь на ветке 2, (<copyBranch> имя ветки от куда надо скопировать состояние для создания новой ветки <newBrenchName>)
- git branch <newBrenchName> <copyBranch>

\\ создание новой ветки и автоматическое переключение на нее
- git checkout -b dev-test (dev-test - новое имя ветки, -b создаст ее если при переключении такой не будет, и автоматически на нее сразу переключится после создания)

   //                       \\
-- \\ удаленные репозитории // --

// настройка SSH подключения, файл создается по пути в папке потзователя с расширением *.pub -> c/Users/User/.ssh/id_rsa.pub
- ssh-keygen
- после система запросит ввести passphrase, для защиты, и потом повторить ее
- для просмотра содержимого SSH файла надо открыть для просмотра файл id_rsa.pub

// для загрузки изменений на локальном компьютере в ГИТХАБ 
- git push

// загрузка данных из удаленного репозитория ГИТ ХАБ
- git pull

// обновить текущую синхрониззацию по данным удаленного репозитория.
- git fetch 

// если при загрузке вышла ошибка на отсутствие нужной ветки, это значи что на удаленном репозитории нет такой ветки, надо создать ее на удаленном репозитории сначала, а потом опять выполнить гит пуш, либо использовать такую команду. 
- git push -u origin <vetka> (это командой мы хотим загрузить с текущей локальной ветке на удаленную (origin) ветку с таким же именем.

// удаление ненужной ветки
- git branch -d <vetka1> <vetka2> (через пробел можно писать несколько веток для удаления)
- git --delete origi <vetka1> <vetka2> (для удаления веток в удаленном репозитории, так как если мы удалим локально, то удаленно они все равно остануться)

// Объеденяет изменения различных веток в 1
- git merge

   //                       \\
-- \\     Перенос ветки     // --

// Rebase - процесс переноса изменения ветки, а именно процесс смены СТАРТА ветки. Процесс когда работа другого разработчика может влиять на мою часть, и потому требуется учитывать и его изменения. Вместо merge можно как раз использовать Rebase, который мои изменения перемещает в тот или инной момент времени. 
- git rebase <vetka>

   //                      \\
-- \\ Управление версиями  // --

// версией продкта в ГИт называет teg и оозначает версию готовой программы, версией записывается последний коммит, формат записи - 1.0.0
- git tag <1.0.0>

// команда работает так же для просмотра версий которые есть 
- git tag

// а так же удаления ненужного тега 
- git tag -d <tag_name>

// для загрузки тегов в ГИТХАБ используем команду 
- git push --tags

// для того чтобы удалить ненужный тег из удаленного репозитория используется команда <tag_name> - тот тег который надо удалить.
- git push --delete origin <tag_name>
--------------------------------
Для добавления в конец файла используй ">>". Одна ">" перезаписывает файл. echo "что игнорировать" >> .gitignore
Основной синтаксис файла .gitignore:
1 Каждая строка - отдельный шаблон
2 Пустые строки игнорируются
3 Строки начинающиеся с # являются комментариями
4 Символ слеша "/" в начале строки указывает на текущую папку (где лежит .gitignore)
5 Звёздочка() заменяет любое количество символов
6 Две звёздочки(*) используются для указания всех подпапок.
7 Восклицательный знак(!) в начале строки инвертирует шаблон (используется для исключений)
8 Для экранирования спецсимволов используется обратный слэш "\". Для игнорирования всей директории, правило должно оканчиваться на слэш(/), в противном случае правило считается именем файла.
-------------------------------

// .gitkeep и .gitignor файлы для исключений 

- .gitkeep -> Сохраняет пустые директории в общем репозитории. Требуется для того чтобы показать какую то папку в которой нет файлов, но гит не заносит их в индекс пока она пустая. 

-gitignore -> Игнорирует некоторые файлы от попадания в общий индекс репозитория.


